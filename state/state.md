# State 模式 (状态模式)
允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改它的类。  
## 优点
- 封装了转换规则
- 枚举了可能状态，枚举状态之前需要确认状态种类
- 将所有与某个状态有关的行为放在一个类中，并且可以方便增加新的状态，只需要改变对象状态就可以改变对象行为  
- 允许状态转换逻辑与状态对象和成一体，而不是某一个巨大的条件语句状态
- 可以让多个环境对象共享一个状态对象，从而减少系统中对象个数
- 分而治之，将复杂的程序分解开来
- 易于增加新的状态
## 缺点
- 状态模式的使用必然会增加系统类和对象的个数。
- 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。
- 状态模式对 "开闭原则" 的支持并不太好，对于可以切换状态的状态模式，
增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。
## 使用场景
- 行为随状态改变而改变场景
- 条件、分支语句的代替
## JDK 实例
- javax.faces.lifecycle.LifeCycle#execute()
## 相关设计模式
- [Singleton 模式](../sigleton/sigleton.md) 常常用于具体的状态类角色中。因为在表示状态的类中并没有定义任何实例字段(即表示实例的状态的字段)
- Flyweight 模式:可以使用该模式在多个 Context 角色之间共享具体状态对象
## 注意事项
- 在行为受状态约束的时候使用状态模式，而且状态个数不超过五个。
- 状态模式可以使用枚举方式实现
